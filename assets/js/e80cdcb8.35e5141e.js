"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[152],{98123:e=>{e.exports=JSON.parse('{"functions":[{"name":"DestroyChannel","desc":"You can use this to destroy channels instead of calling ``:Destroy()`` on a channel.","params":[{"name":"WhatToDestroy","desc":"","lua_type":"string | Channel"}],"returns":[],"function_type":"static","source":{"line":396,"path":"src/init.lua"}},{"name":"GetChannelObject","desc":"You can use this function to get a Channel Object by providing the name of the Channel, if the Channel does not exist then nil will be returned ","params":[{"name":"ChannelName","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Channel?"}],"function_type":"static","source":{"line":414,"path":"src/init.lua"}},{"name":"Cast","desc":"Cast a ray similiar to ``workspace:Raycast()``. If you want identical usage as the normal roblox method you can do the following:\\n\\n```lua\\nlocal SmartRaycast = PathToModule\\nlocal Channel = SmartRaycast.CreateChannel(\\"ExampleChannel\\")\\n\\nlocal MyResult = workspace:Raycast(Origin,Direction,Channel.RayParams)\\n```","params":[{"name":"Origin","desc":"","lua_type":"Vector3"},{"name":"Direction","desc":"","lua_type":"Vector3"},{"name":"ChannelName","desc":"","lua_type":"string"}],"returns":[],"function_type":"static","source":{"line":432,"path":"src/init.lua"}},{"name":"CreateChannel","desc":":::warning \\nIf you rely on constantly creating and destroying channels, you should set the ``.SanityCheck`` property of the module to false to avoid potential overhead.\\n:::\\n\\n:::note\\nInstanceLogic Example:\\n```lua\\nlocal function InstanceLogic(Inst: Instance)\\n\\tif Inst.Size.X > 100 then -- this will never error due pcall so it is safe\\n\\t\\treturn true \\n\\tend\\nend\\n```\\n:::\\nCreates a new channel.","params":[{"name":"ChannelName","desc":"Name of the channel that will be created.","lua_type":"string"},{"name":"BaseArray","desc":"Instances that will always remain present in the FilterDescendantsInstances Array.","lua_type":"{ Instance }?"},{"name":"InstancesToCheck","desc":"Instances that will have their Descendants checked in runtime using the \'InstanceLogic\' function.","lua_type":"{ Instance }?"},{"name":"InstanceLogic","desc":"A function that should recieve an instance and return true if the instance should be added in the FilterDescendantsInstances Array. This function is run in protected call so you don\'t need to worry about any errors.","lua_type":"((any) -> boolean | nil)?"},{"name":"FilterType","desc":"","lua_type":"Enum.RaycastFilterType?"},{"name":"IgnoreWater","desc":"","lua_type":"boolean?"},{"name":"CollisionGroup","desc":"","lua_type":"string?"},{"name":"RespectCanCollide","desc":"","lua_type":"boolean?"},{"name":"BruteForceAllSlow","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Channel"}],"function_type":"static","source":{"line":468,"path":"src/init.lua"}}],"properties":[{"name":"SanityCheck","desc":"Setting this property to false will disable sanity checking.","lua_type":"boolean","source":{"line":28,"path":"src/init.lua"}},{"name":"Warnings","desc":"Setting this property to false will disable warnings.","lua_type":"boolean","source":{"line":35,"path":"src/init.lua"}}],"types":[],"name":"SmartRaycast","desc":"","source":{"line":21,"path":"src/init.lua"}}')}}]);